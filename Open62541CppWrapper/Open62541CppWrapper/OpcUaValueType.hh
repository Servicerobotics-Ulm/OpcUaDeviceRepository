//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// Please do not modify this file. It will be re-generated
// running the code generator.
//--------------------------------------------------------------------------

#ifndef OPCUA_VALUETYPET_HH_
#define OPCUA_VALUETYPET_HH_

#include <string>
#include <vector>

#ifdef HAS_OPCUA
	#ifdef UA_ENABLE_AMALGAMATION
		#include <open62541.h>
	#else
		#include <open62541/types.h>
	#endif
#else
	#include <sstream>
#endif

namespace OPCUA {

class ValueType
{
public:
#ifdef HAS_OPCUA
	typedef UA_Variant NativeVariantType;
#else
	typedef std::stringstream NativeVariantType;
#endif
private:
	NativeVariantType _value;

protected:
	/// deep-copy the value into internal structure
	template <typename T>
	void copy(const T &var, const bool &cleanupPreviousValue=true);

	/// copy an array of values into the internal structure
	template <typename T>
	void copy(const std::vector<T> &var, const bool &cleanupPreviousValue=true);

public:
	/// default constructor
	ValueType();

	/// object copy constructor
	ValueType(const ValueType &value);

	/// internal value pointer-type copy constructor
	ValueType(const NativeVariantType *value);

	/// reference-type copy constructor
	template <typename T>
	ValueType(const T &value) {
		this->copy(value, false);
	}

	/// array-type copy constructor
	template <typename T>
	ValueType(const std::vector<T> &value) {
		this->copy(value, false);
	}

	/// default destructor
	virtual ~ValueType();

	/// check whether the current internal representation is an array or a scalar type
	bool isArrayType() const;

	/// checks whether the internal value has been setup to any actual value
	bool isEmpty() const;

	/// method checks if the internal value is an integer type
	bool isIntegerType() const;
	/// method checks if the internal value is a boolean type
	bool isBooleanType() const;
	/// method checks if the internal value is a double (i.e. floating) type
	bool isDoubleType() const;
	/// method checks if the internal value is a string type
	bool isStringType() const;

	/// object-type copy assigned operator (overrides and frees previous internal value)
	ValueType& operator=(const ValueType &value);

	/// internal value pointer-type assignment copy operator
	ValueType& operator=(const NativeVariantType *value);

	// reference-type assignment operator
	template <typename T>
	ValueType& operator=(const T &value) {
		// use the specific copy methods to create an internal value copy
		this->copy(value);
		return *this;
	}

	/// array-type assignment operator
	template <typename T>
	ValueType& operator=(const std::vector<T> &value) {
		// use the specific copy methods to create an internal value copy
		this->copy(value);
		return *this;
	}

	/// type-specific conversion operator
	template <typename T>
	operator T() const;

	/// explicit conversion operator for a C string (use "static_cast<const char*>(this-object)" to select this operator)
	explicit operator const char*() const;

	/// type-specific conversion operator for array types
	template <typename T>
	operator std::vector<T>() const;

	/// direct const (i.e. read-only) access to internal representation (no copy)
	inline operator const NativeVariantType*() const
	{
		return &_value;
	}

	/// to string conversion
	std::string toString() const;
};

/// ostream operator
inline std::ostream& operator << (std::ostream& os, const ValueType& vt)
{
	os << vt.toString();
	return os;
}

} /* namespace OPCUA */

#endif /* OPCUA_VALUETYPET_HH_ */
