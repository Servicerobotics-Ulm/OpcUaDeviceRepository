//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// Please do not modify this file. It will be re-generated
// running the code generator.
//--------------------------------------------------------------------------

#include "OpcUaProductionStation.hh"
	
namespace OPCUA {

ProductionStation::ProductionStation(ProductionStationInterface *controller)
:	OPCUA::GenericServer("ProductionStation")
,	controller(controller)
{
	
}
ProductionStation::~ProductionStation()
{  }

bool ProductionStation::createServerSpace() 
{
	// add variable isBoxPresent
	bool isBoxPresentReadOnly = true;
	bool isBoxPresentValue = false;
	if(addVariableNode("isBoxPresent", isBoxPresentValue, isBoxPresentReadOnly) != true) {
		std::cout << "failed adding isBoxPresent" << std::endl;
		return false;
	}
	
	// add variable LED_RED
	bool LED_REDReadOnly = false;
	bool LED_REDValue = false;
	if(addVariableNode("LED_RED", LED_REDValue, LED_REDReadOnly) != true) {
		std::cout << "failed adding LED_RED" << std::endl;
		return false;
	}
	
	// add variable LED_YELLOW
	bool LED_YELLOWReadOnly = false;
	bool LED_YELLOWValue = false;
	if(addVariableNode("LED_YELLOW", LED_YELLOWValue, LED_YELLOWReadOnly) != true) {
		std::cout << "failed adding LED_YELLOW" << std::endl;
		return false;
	}
	
	// add variable LED_GREEN
	bool LED_GREENReadOnly = false;
	bool LED_GREENValue = false;
	if(addVariableNode("LED_GREEN", LED_GREENValue, LED_GREENReadOnly) != true) {
		std::cout << "failed adding LED_GREEN" << std::endl;
		return false;
	}
	
	
	// add the method loadbox
	std::map<std::string, OPCUA::Variant> loadboxInputArguments;
	loadboxInputArguments["timeout"] = 0;
	
	std::map<std::string, OPCUA::Variant> loadboxOutputArguments;
	loadboxOutputArguments["result"] = std::string();
	
	if(addMethodNode("loadbox", loadboxInputArguments, loadboxOutputArguments) != true) {
		std::cout << "failed adding loadbox" << std::endl;
		return false;
	}
	
	// add the method start_unloading
	std::map<std::string, OPCUA::Variant> start_unloadingInputArguments;
	start_unloadingInputArguments["XtimeoutX"] = 0;
	
	std::map<std::string, OPCUA::Variant> start_unloadingOutputArguments;
	start_unloadingOutputArguments["result"] = std::string();
	
	if(addMethodNode("start_unloading", start_unloadingInputArguments, start_unloadingOutputArguments) != true) {
		std::cout << "failed adding start_unloading" << std::endl;
		return false;
	}
	
	// add the method stop_unloading
	std::map<std::string, OPCUA::Variant> stop_unloadingInputArguments;
	stop_unloadingInputArguments["XtimeoutX"] = 0;
	
	std::map<std::string, OPCUA::Variant> stop_unloadingOutputArguments;
	stop_unloadingOutputArguments["result"] = std::string();
	
	if(addMethodNode("stop_unloading", stop_unloadingInputArguments, stop_unloadingOutputArguments) != true) {
		std::cout << "failed adding stop_unloading" << std::endl;
		return false;
	}
	
	return true;
}

void ProductionStation::handleOnRead(const std::string &browseName, Variant &value)
{
	if(browseName == "isBoxPresent") {
		bool isBoxPresent;
		if(controller->getIsBoxPresent(isBoxPresent) == OPCUA::StatusCode::ALL_OK) {
			value = isBoxPresent;
		}
	} else if(browseName == "LED_RED") {
		bool LED_RED;
		if(controller->getLED_RED(LED_RED) == OPCUA::StatusCode::ALL_OK) {
			value = LED_RED;
		}
	} else if(browseName == "LED_YELLOW") {
		bool LED_YELLOW;
		if(controller->getLED_YELLOW(LED_YELLOW) == OPCUA::StatusCode::ALL_OK) {
			value = LED_YELLOW;
		}
	} else if(browseName == "LED_GREEN") {
		bool LED_GREEN;
		if(controller->getLED_GREEN(LED_GREEN) == OPCUA::StatusCode::ALL_OK) {
			value = LED_GREEN;
		}
	}
}

void ProductionStation::handleOnWrite(const std::string &browseName, const Variant &value)
{
	// propagate the write calls to respective upcalls (only if write access is activated)
	if(browseName == "LED_RED") {
		controller->setLED_RED(value);
	} else if(browseName == "LED_YELLOW") {
		controller->setLED_YELLOW(value);
	} else if(browseName == "LED_GREEN") {
		controller->setLED_GREEN(value);
	}
}

void ProductionStation::handleMethodCall(const std::string &browseName, const std::vector<Variant> &inputs, std::vector<Variant> &outputs)
{
	if(browseName == "loadbox") {
		// expecting an input vector of size 1
		if(inputs.size() == 1) {
			// input variables
			int timeout = inputs[0];
			// output variables
			std::string result;
			// method call propagation
			controller->callLoadbox(timeout, result);
			// fill output vector
			outputs.resize(1);
			outputs[0] = result;
		}
	} else if(browseName == "start_unloading") {
		// expecting an input vector of size 1
		if(inputs.size() == 1) {
			// input variables
			int XtimeoutX = inputs[0];
			// output variables
			std::string result;
			// method call propagation
			controller->callStart_unloading(XtimeoutX, result);
			// fill output vector
			outputs.resize(1);
			outputs[0] = result;
		}
	} else if(browseName == "stop_unloading") {
		// expecting an input vector of size 1
		if(inputs.size() == 1) {
			// input variables
			int XtimeoutX = inputs[0];
			// output variables
			std::string result;
			// method call propagation
			controller->callStop_unloading(XtimeoutX, result);
			// fill output vector
			outputs.resize(1);
			outputs[0] = result;
		}
	}
}

} /* namespace OPCUA */
